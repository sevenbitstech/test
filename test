'Authorization: Bearer AAAAAAAAAAAAAAAAAAAAAFnz2wAAAAAACOwLSPtVT5gxxxxxxxxxxxx'
def new_method(self, url, params, data, method):
        print(method)
        print(url)
        print(params)
        print(data)
        print('/'.join((self.base_url, url)))
    def multipage_search(self, url, query, media_type=None):
        """Wrapper for GitHub API methods that use pagination"""

        if media_type is None:
           media_type = 'application/vnd.github.v3.text-match+json'
        results = []
        params = {
            'per_page': self.per_page,
            'q':'org:sevenbitstech '+query,
            'page': 1
        }
        self.session.headers.update({'Accept': media_type})
        print(url)
        response = self.make_request('/'.join((self.base_url, url)), params=params)
        for value in response.json().get('items'):
            results.append(value)

        if response.links.get('last'):
            total_pages = response.links.get('last').get('url')[response.links.get('last').get('url').rindex('=') + 1:]
            for page in range(2, int(total_pages) + 1):
                time.sleep(2)
                params['page'] = str(page)
                response = self.make_request('/'.join((self.base_url, url)), params=params)
                for value in response.json().get('items'):
                    results.append(value)

        return results

    def get_user(self):
        return self.make_request('/'.join((self.base_url, 'user'))).json()

    def get_repository(self, fullname):
        return self.make_request('/'.join((self.base_url, 'repos/{}'.format(fullname)))).json()


def initiate_github_connection():
    """Create a GitHub API client object"""

    try:
        token = os.environ['GITHUB_WATCHMAN_TOKEN']
    except KeyError:
        with open('{}/watchman.conf'.format(os.path.expanduser('~'))) as yaml_file:
            config = yaml.safe_load(yaml_file)

        token = config.get('github_watchman').get('token')

    try:
        url = os.environ['GITHUB_WATCHMAN_URL']
    except KeyError:
        with open('{}/watchman.conf'.format(os.path.expanduser('~'))) as yaml_file:
            config = yaml.safe_load(yaml_file)

        url = config.get('github_watchman').get('url')

    return GitHubAPIClient(token, url)


def convert_time(timestamp):
    """Convert ISO 8601 timestamp to epoch """

    pattern = '%Y-%m-%dT%H:%M:%SZ'
    return int(time.mktime(time.strptime(timestamp, pattern)))


def deduplicate(input_list):
    """Removes duplicates where results are returned by multiple queries"""

    list_of_strings = [json.dumps(d, sort_keys=True) for d in input_list]
    list_of_strings = set(list_of_strings)
    return [json.loads(s) for s in list_of_strings]


def search_code(github: GitHubAPIClient, log_handler, rule, timeframe=cfg.ALL_TIME):
    """Uses the Search API to get code fragments matching a search term.
        This is then filtered by regex to find true matches"""

    results = []
    now = calendar.timegm(time.gmtime())
    if isinstance(log_handler, logger.StdoutLogger):
        print = log_handler.log_info
    else:
        print = builtins.print

    for query in rule.get('strings'):
        code_list = github.multipage_search('search/code', query)
        if code_list:
            print('{} code fragments found matching: {}'.format(len(code_list), query.replace('"', '')))
            if timeframe != cfg.ALL_TIME:
                for code in code_list:
                    r = re.compile(rule.get('pattern'))
                    repository = github.get_repository(code.get('repository').get('full_name'))
                    if convert_time(repository.get('updated_at')) > (now - timeframe) and r.search(str(code.get('text_matches'))):
                        match_list = []
                        for match in code.get('text_matches'):
                            match_list.append({
                                'object_url': match.get('object_url'),
                                'object_type': match.get('object_type'),
                                'fragment': match.get('fragment')
                            })

                        results_dict = {
                            'file_name': code.get('name'),
                            'file_url': code.get('html_url'),
                            'sha': code.get('sha'),
                            'repository': {
                                'repository_id': code.get('repository').get('id'),
                                'repository_node_id': code.get('repository').get('node_id'),
                                'repository_name': code.get('repository').get('name'),
                                'repository_url': code.get('repository').get('html_url'),
                            },
                            'matches': match_list
                        }

                        results.append(results_dict)
            else:
                for code in code_list:
                    r = re.compile(rule.get('pattern'))
                    if r.search(str(code.get('text_matches'))):
                        match_list = []
                        for match in code.get('text_matches'):
                            match_list.append({
                                'object_url': match.get('object_url'),
                                'object_type': match.get('object_type'),
                                'fragment': match.get('fragment')
                            })

                        results_dict = {
                            'file_name': code.get('name'),
                            'file_url': code.get('html_url'),
                            'sha': code.get('sha'),
                            'repository': {
                                'repository_id': code.get('repository').get('id'),
                                'repository_node_id': code.get('repository').get('node_id'),
                                'repository_name': code.get('repository').get('name'),
                                'repository_url': code.get('repository').get('html_url'),
                            },
                            'matches': match_list
                        }

                        results.append(results_dict)
        else:
            print('No code fragments found matching: {}'.format(query.replace('"', '')))
    if results:
        results = deduplicate(results)
        print('{} total matches found after filtering'.format(len(results)))
        return results
